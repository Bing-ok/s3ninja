/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package ninja;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;

import java.io.IOException;

/**
 * Handles chunks of data which contains signatures generated by the AWS SDK.
 * <p>
 * We currently do not check the signature of each token, as we checked the request signature.
 * This seems to do the job for a test / mock sever for now.
 */
class SignedChunkHandler extends sirius.web.http.InputStreamHandler {

    private int remainingBytes = 0;

    @Override
    public void handle(ByteBuf content, boolean last) throws IOException {
        if (!content.isReadable()) {
            super.handle(content, last);
            return;
        }

        while(true) {
            if (remainingBytes > 0) {
                if (content.writerIndex() - content.readerIndex() > remainingBytes) {
                    super.handle(content.slice(content.readerIndex(), remainingBytes), false);
                    content.readerIndex(content.readerIndex() + remainingBytes);
                    remainingBytes = 0;
                    skipSignature(content);
                } else {
                    super.handle(content, last);
                    remainingBytes -= content.writerIndex() - content.readerIndex();
                    return;
                }
            }

            if (remainingBytes == 0) {
                String lengthString = readChunkLengthHex(content);
                remainingBytes = Integer.parseInt(lengthString, 16);
                skipSignature(content);
                if (remainingBytes == 0) {
                    skipSignature(content);
                    super.handle(Unpooled.EMPTY_BUFFER, true);
                    if (content.writerIndex() == content.readerIndex()) {
                        return;
                    }
                }
            }
        }
    }

    private void skipSignature(ByteBuf content) {
        while (content.isReadable()) {
            if (content.readByte() == '\r' && content.readByte() == '\n') {
                return;
            }
        }
    }

    private String readChunkLengthHex(ByteBuf content) {
        StringBuilder lengthString = new StringBuilder();
        while (content.isReadable()) {
            byte data = content.readByte();
            if (data == ';') {
                return lengthString.toString();
            }
            lengthString.append((char) data);
        }
        return lengthString.toString();
    }
}
